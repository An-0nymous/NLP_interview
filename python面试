一、迭代器协议x
1.迭代器协议是指：对象必须提供一个next方法，执行该方法要么返回迭代中的下一项，要么就引起一个StopIteration异常，以终止迭代 （只能往后走不能往前退）
2.可迭代对象：实现了迭代器协议的对象（如何实现：对象内部定义一个__iter__()方法）
，可迭代对象实现了迭代器协议，python的内部工具（如for循环，sum，min，max函数等)使用迭代器协议访问对象。
for 循环机制
for循环的本质：循环所有对象，全都是使用迭代器协议。
列表，字符串，元组，字典，集合，文件对象等本质上来说都不是可迭代对象，在使用for循环的时候内部是先调用他们内部的iter方法，使他们变成了可迭代对象，然后在使用可迭代对象的next方法依次循环元素，当元素循环完时，会触发StopIteration异常，for循环会捕捉到这种异常，终止迭代

二、生成器
语法上和函数类似：生成器函数和常规函数几乎是一样的。它们都是使用def语句进行定义，差别在于，生成器使用yield语句返回一个值，而常规函数使用return语句返回一个值（只要一个函数内出现了yield，那它就是一个生成器函数，执行这个函数就得到一个生成器）
自动实现迭代器协议：对于生成器，Python会自动实现迭代器协议，以便应用到迭代背景中（如for循环，sum函数）。由于生成器自动实现了迭代器协议，所以，我们可以调用它的next方法，并且，在没有值可以返回的时候，生成器自动产生StopIteration异常
状态挂起：生成器使用yield语句返回一个值。yield语句挂起该生成器函数的状态，保留足够的信息，以便之后从它离开的地方继续执行
生成器的唯一注意事项就是：生成器只能遍历一次。

将列表生成式中[]改成() 之后数据结构是否改变？ 答案：是，从列表变为生成器
通过列表生成式，可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含百万元素的列表，不仅是占用很大的内存空间，如：我们只需要访问前面的几个元素，后面大部分元素所占的空间都是浪费的。因此，没有必要创建完整的列表（节省大量内存空间）。在Python中，我们可以采用生成器：边循环，边计算的机制—>generator


三、内存管理和垃圾回收机制
Python GC主要使用引用计数（reference counting）来跟踪和回收垃圾。在引用计数的基础上，通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用问题，通过“分代回收”（generation）以空间换时间的方法提高垃圾回收效率。  
1. 内存管理&引用计数
python创建新对象都是在内存上开辟一个块, 每个对象只存有一份数据, 赋值和复制都是创建了新的引用, 使用的是对象和引用分离策略.在Python中，每个对象都有存有指向该对象的引用总数，即引用计数, 如果引用计数为0, 那这个对象就会被python垃圾回收机制回收
2. 标记-清除机制
基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发，遍历以对象为节点、以引用为边构成的图，把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。
同时为了保证效率, Python只会在垃圾达到一定阈值时，垃圾回收才会启动。
3. 分代回收策略
这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。Python默认定义了三代对象集合，索引数越大，对象存活时间越长。

四、单下划线和双下划线
前者 ：一种约定,用来指定变量私有，程序员用来指定私有变量的一种方式；后者：一种约定,Python内部的名字,用来区别其他用户自定义的命名，以防冲突。

五、Python作用域简单说就是一个变量的命名空间。代码中变量被赋值的位置，就决定了哪些范围的对象可以访问这个变量，这个范围就是变量的作用域。
在Python中，只有模块（module），类（class）以及函数（def、lambda）才会引入新的作用域。
Python的变量名解析机制也称为 LEGB 法则：本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）→全局/模块作用域（Global）→内置作用域（Built-in）
在L中修改nON-L:可在L内 加上global(L中修改G)，nonlocal(L中修改E)
https://www.jianshu.com/p/17a9d8584530


六、Python-copy()与deepcopy()区别
—–我们寻常意义的复制就是深复制，即将被复制对象完全再复制一遍作为独立的新个体单独存在。所以改变原有被复制对象不会对已经复制出来的新对象产生影响。
—–而浅复制并不会产生一个独立的对象单独存在，他只是将原有的数据块打上一个新标签，所以当其中一个标签被改变的时候，数据块就会发生变化，另一个标签也会随之改变。

第一：非容器类型（不可变对象, 比如数字，字符串和其他原子类型的对象，例如代码，类型和range对象等）没有拷贝一说，浅拷贝是完全用切片操作来完成的。
第二：如果元组变量只包含原子类型对象，那么深拷贝将不会进行。
七、捕获异常
try...except...finally语句:当try语句执行时发生异常，回到try语句层，寻找后面是否有except语句。
找到except语句后，会调用这个自定义的异常处理器。except将异常处理完毕后，程序继续往下执行。finally语句表示，无论异常发生与否，finally中的语句都要执行。
assert语句：判断assert后面紧跟的语句是True还是False，如果是True则继续执行print，如果是False则中断程序，调用默认的异常处理器，同时输出assert语句逗号后面的提示信息。
with语句：如果with语句或语句块中发生异常，会调用默认的异常处理器处理，但文件还是会正常关闭。

八、请简述线程、进程、协程的特性
进程是系统进行资源分配和调度的最小单位,进程是线程的容器,一个进程可以包含多个线程,进程之间数据不能互相访问。线程是CPU调度的最小单位,线程是程序执行流的最小单元, 每一个进程都至少有一个线程, 线程之间数据可以共享。进程线程都是由操作系统调度,python中多线程和多进程都是通过切换上下文来实现,都会耗费额外的系统资源
协程由程序员调度, 由代码切换来控制, 系统并不知道协程的存在, 各种多并发异步非阻塞模块都是基于协程来实现的
进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间，而协程就是用户自己控制切换的时机，不再需要陷入系统的内核态。Python里最常见的yield就是协程的思想
线程有几种状态?生命周期是怎样的?
线程有五种状态:创建、就绪、运行、阻塞、死亡。
调用start方法时，线程就会进入就绪状态。
在线程得到cpu时间片时进入运行状态。
线程调用yield方法可以让出cpu时间回到就绪状态。
线程运行时可能由于IO、调用sleep、wait、join方法或者无法获得同步锁等原因进入阻塞状态。
当线程获得到等待的资源资源或者引起阻塞的条件得到满足时，会从阻塞状态进入就绪状态。
当线程的run方法执行结束时，线程就进入死亡状态。

八、闭包
闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。
当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:
必须有一个内嵌函数
内嵌函数必须引用外部函数中的变量
外部函数的返回值必须是内嵌函数


九、装饰器
Python自省：
自省就是面向对象的语言所写的程序在运行时,所能知道对象的类型.简单一句就是运行时能够获得对象的类型.比如type(),dir(),getattr(),hasattr(),isinstance().
十二、字典推导式d = {key: value for (key, value) in iterable}
十三、字符串格式化:%和.format
A.foramt会把参数按位置顺序来填充到字符串中，第一个参数是0，然后1 ……
也可以不输入数字，这样也会按顺序来填充
同一个参数可以填充多次，这个是format比%先进的地方
B.通过列表填充
list=['world','python']
print('hello {names[0]}  i am {names[1]}'.format(names=list))# 输出结果：hello world  i am python
print('hello {0[0]}  i am {0[1]}'.format(list)) #输出结果：hello world  i am python

>>>"{} {}".format("hello", "world") # 不设置指定位置，按默认顺序 'hello world' >>>
 "{0} {1}".format("hello", "world") # 设置指定位置 'hello world' >>> 
"{1} {0} {1}".format("hello", "world") # 设置指定位置 'world hello world'

对于%最烦人的是它无法同时传递一个变量和元组.

十四、*args and **kwargs
当你不确定你的函数里将要传递多少参数时你可以用*args.例如,它可以传递任意数量的参数；**kwargs允许你使用没有事先定义的参数名:
单例模式
通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。
__new__()在__init__()之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例 这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的.
is是对比地址,==是对比值

Random
`random.random()`函数可以生成`[0.0, 1.0)`之间的随机浮点数。
2. `random.uniform(a, b)`函数可以生成`[a, b]`或`[b, a]`之间的随机浮点数。
3. `random.randint(a, b)`函数可以生成`[a, b]`或`[b, a]`之间的随机整数。
4. `random.shuffle(x)`函数可以实现对序列`x`的原地随机乱序。
5. `random.choice(seq)`函数可以从非空序列中取出一个随机元素。
6. `random.choices(population, weights=None, *, cum_weights=None, k=1)`函数可以从总体中随机抽取（有放回抽样）出容量为`k`的样本并返回样本的列表，可以通过参数指定个体的权重，如果没有指定权重，个体被选中的概率均等。
7. `random.sample(population, k)`函数可以从总体中随机抽取（无放回抽样）出容量为`k`的样本并返回样本的列表。

> **扩展**：`random`模块提供的函数除了生成均匀分布的随机数外，还可以生成其他分布的随机数，例如`random.gauss(mu, sigma)`函数可以生成高斯分布（正态分布）的随机数；`random.paretovariate(alpha)`函数会生成帕累托分布的随机数；`random.gammavariate(alpha, beta)`函数会生成伽马分布的随机数。

可变类型和不可变类型
1,可变类型有list,dict.不可变类型有string，number,tuple.(开辟新的内存）以int类型为例:实际上 i += 1 并不是真的在原有的int对象上+1，而是重新创建一个value为6的int对象，i引用自这个新的对象。
不可变数据类型在第一次声明赋值声明的时候, 会在内存中开辟一块空间, 用来存放这个变量被赋的值, 而这个变量实际上存储的, 并不是被赋予的这个值, 而是存放这个值所在空间的内存地址, 通过这个地址, 变量就可以在内存中取出数据了. 所谓不可变就是说, 我们不能改变这个数据在内存中的值, 所以当我们改变这个变量的赋值时, 只是在内存中重新开辟了一块空间, 将这一条新的数据存放在这一个新的内存地址里, 而原来的那个变量就不在引用原数据的内存地址而转为引用新数据的内存地址了,相当于改变了变量指向的内存地址.
2,当进行修改操作时，可变类型传递的是内存中的地址，也就是说，直接修改内存中的值，并没有开辟新的内存。
3,不可变类型被改变时，并没有改变原内存地址中的值，而是开辟一块新的内存，将原地址中的值复制过去，对这块新开辟的内存中的值进行操作。
不可变参数用值传递：像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象。
可变参数是引用传递：比如像列表，字典这样的对象是通过引用传递、和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变。

Super()
你想在子类中调用父类的某个已经被覆盖的方法。为了调用父类(超类)的一个方法，可以使用 super() 函数，super() 函数的一个常见用法是在 __init__() 方法中确保父类被正确的初始化了

Python中如何动态获取和设置对象的属性？
if hasattr(Parent, 'x'):
    print(getattr(Parent, 'x'))
    setattr(Parent, 'x',3)print(getattr(Parent,'x'))

.内存泄露是什么？如何避免？内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。有__del__()函数的对象间的循环引用是导致内存泄露的主凶。不使用一个对象时使用: del object 来删除一个对象的引用计数就可以有效防止内存泄露问题。
通过Python扩展模块gc 来查看不能回收的对象的详细信息。可以通过 sys.getrefcount(obj) 来获取对象的引用计数，并根据返回值是否为0来判断是否内存泄露
Dir(“a”)输出字符串'a'的内建方法
什么是lambda函数？ 有什么好处？
lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的函数
1.lambda函数比较轻便，即用即仍，很适合需要完成一项功能，但是此功能只在此一处使用，连名字都很随意的情况下
1）直接赋给一个变量，然后再像一般函数那样调用c=lambda x,y,z:x*y*z  c(2,3,4) 24
当然，也可以在函数后面直接传递实参 (lambda x:x**2)(3) 9
将lambda函数作为参数传递给其他函数比如说结合map、filter、sorted、reduce等一些Python内置函数使用，与sorted函数结合使用，比如：创建由元组构成的列表：
a=[('b',3),('a',2),('d',4),('c',1)]
按照第一个元素排序
sorted(a,key=lambda x:x[0])
[('a',2),('b',3),('c',1),('d',4)]

Names = ['Anne', 'Amy', 'Bob', 'David', 'Carrie', 'Barbara', 'Zach']
B_Name= filter(lambda x: x.startswith('B'),Names)
求字符串每个单词的长度
sentence = "Welcome To Beijing!"words = sentence.split()lengths  = map(lambda x:len(x),words)print(list(lengths))
Python中yield的用法?
yield就是保存当前程序执行状态。你用for循环的时候，每次取一个元素的时候就会计算一次。用yield的函数叫generator,和iterator一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间，generator每次计算需要上一次计算结果，所以用yield,否则一return，上次计算结果就没了
调用gen example方法并没有输出任何内容，说明函数体的代码尚未开始执行。当调用generator的next方法，generator会执行到yield 表达式处，返回yield表达式的内容，然后暂停（挂起）在这个地方，所以第一次调用next打印第一句并返回“first yield”。 暂停意味着方法的局部变量，指针信息，运行环境都保存起来，直到下一次调用next方法恢复。第二次调用next之后就暂停在最后一个yield，再次调用next()方法，则会抛出StopIteration异常。　因为for语句能自动捕获StopIteration异常，所以generator（本质上是任何iterator）较为常用的方法是在循环中使用
　generator function产生的generator与普通的function有什么区别呢
　　（1）function每次都是从第一行开始运行，而generator从上一次yield开始的地方运行
　　（2）function调用一次返回一个（一组）值，而generator可以多次返回
（3）function可以被无数次重复调用，而一个generator实例在yield最后一个值 或者return之后就不能继续调用了
代码字面上看来也就是中括号与小括号的区别。但这点区别差异是很大的，第一种方法返回值是一个列表，第二个方法返回的是一个generator对象。随着RANGE_NUM的变大，第一种方法返回的列表也越大，占用的内存也越大；但是对于第二种方法没有任何区别。我们再来看一个可以“返回”无穷多次的例子：
def fib():    a, b = 1, 1   while True:   yield a    a, b = b, a+b 

开源本体编辑工具，叫 Protégé。这个工具是斯坦福大学开源的，它的功能非常强大，也是目前最流行的本体编辑工具，有网页版和桌面版，桌面版是免安装的，大家直接下载下来就可以试用。
它的好处是什么？它屏蔽了具体的本体描述语言，用户只需要在概念层次上面进行本体的模型构建，同时也比较灵活，能够支持各种插件来扩展特定的功能。比如推理的功能可以基于插件来扩展。不过这个工具对中文的支持不是很友好。
1、实例方法，必须要创建实例才能调用，里面有self关键字，有初始化函数必须对初始化函数进行传参。
类方法，可以直接类名.方法名直接调用，也可以创建实例调用。里面有cls关键字，调用时，直接类名.方法名，可以绕过实例方法的初始化函数，类方法不能访问实例属性。
静态方法，可以直接类名.方法名直接调用，也可以创建实例调用。没有关键字，就像调用函数一样方便，调用时，直接类名.方法名，可以绕过实例方法的初始化函数，静态方法不能访问实例属性。
2、假设我们要增强now()函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改now()函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。
本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，


